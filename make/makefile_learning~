make -p (for default variables);

$@:target
$< first prerequites
$^ all    ""



target … : prerequisites …
        recipe
        …
        …

target :
A target is usually the name of a file that is generated by a program; examples of targets are executable or object files. A target can also be the name of an action to carry out, such as ‘clean’
When a target is a file(example  edit is a file ), it needs to be recompiled or relinked if any of its prerequisites change. In addition, any prerequisites that are themselves automatically generated should be updated first.
The target `clean' is not a file, but merely the name of an action.

prereuisites:
A prerequisite is a file that is used as input to cregsettings set com.canonical.Unity.Launcher launcher-position Bottomate the target. A target often depends on several files.
A recipe:
 	is an action that make carries out.
	A recipe is an action that make carries out. A recipe may have more than one command, either on the same line or each on its own line. Please note: you need to put a tab character at the beginning of every recipe line! This is an obscurity that catches the unwary. If you prefer to prefix your recipes with a character other than tab, you can set the .RECIPEPREFIX variable to an alternate character

phony:
The target `clean' is not a file, but merely the name of an action. Since you normally do not want to carry out the actions in this rule, `clean' is not a prerequisite of any other rule. Consequently, make never does anything with it unless you tell it specifically. Note that this rule not only is not a prerequisite, it also does not have any prerequisites, so the only purpose of the rule is to run the specified commands. Targets that do not refer to files but are just actions are called phony targets.

Targets that do not refer to files but are just actions are called phony targets.

example:clean :
        rm edit main.o kbd.o command.o display.o \
           insert.o search.o files.o utils.o
here (clean) is a target but not a file like (edit) it doesnot have prereqites, it just run some actions and clean is alos not a any prereuicite for any target. 

How make Processes a Makefile

By default, make starts with the first target (not targets whose names start with ‘.’). This is called the default goal. (Goals are the targets that make strives ultimately to update. You can override tHow make Processes a Makefile

By default, make starts with the first target (not targets whose names start with ‘.’). This is called the default goal. (Goals are the targets that make strives ultimately to update. You can override this behavior using the command line (see Arguments to Specify the Goals) or with the .DEFAULT_GOAL special variablehis behavior using the command line (see Arguments to Specify the Goals) or with the .DEFAULT_GOAL special variable




VARIABLES::Variables can represent lists of file names, options to pass to compilers, programs to run, directories to look in for source files, directories to write output in, or anything else you can imagine.
Variable names are case-sensitive. The names `foo', `FOO', and `Foo' all refer to different variables. 

To substitute a variable's value, write a dollar sign followed by the name of the variable in parentheses or braces: either `$(foo)' or `${foo}' is a valid reference to the variable foo.

edit : main.o kbd.o command.o display.o \
       insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o

main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit main.o kbd.o command.o display.o \
           insert.o search.o files.o utils.o



#######
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

#####

edit : $(objects)
        cc -o edit $(objects)






Conditional assignment (?=)

Conditional assignment assigns a value to a variable only if it does not have a value
Appending (+=)

Assume that CC = gcc then the appending operator is used like CC += -w
then CC now has the value gcc -W


Makefiles contain five kinds of things: 
                      1-> explicit rules, 
                      2-> implicit rules,
                      3-> variable definitions,
                      4-> directives, and comments.
`#' in a line of a makefile starts a comment.

What Name to Give Your Makefile:
By default, when make looks for the makefile, it tries the following names, in order: `GNUmakefile', `makefile' and `Makefile'.
The default makefile names `GNUmakefile', `makefile' and `Makefile' are not checked automatically if you specify `-f' or `--file'.

make -d for debugging information

Include:
 For example, if you have three `.mk' files, `a.mk', `b.mk', and `c.mk', and $(bar) expands to bish bash, then the following expression

include foo *.mk $(bar)

is equivalent to

include foo a.mk b.mk c.mk bish bash

If the specified name does not start with a slash, and the file is not found in the current directory, several other directories are searched. First, any directories you have specified with the `-I' or `--include-dir' option are searched (see section Summary of Options). Then the following directories (if they exist) are searched, in this order: `prefix/include' (normally `/usr/local/include' (1)) `/usr/gnu/include', `/usr/local/include', `/usr/include'.

If an included makefile cannot be found in any of these directories, a warning message is generated, but it is not an immediately fatal error; processing of the makefile containing the include continues. Once it has finished reading makefiles, make will try to remake any that are out of date or don't exist. See section How Makefiles Are Remade. Only after it has tried to find a way to remake a makefile and failed, will make diagnose the missing makefile as a fatal error.

If you want make to simply ignore a makefile which does not exist and cannot be remade, with no error message, use the -include directive instead of include, like this:

-include filenames...


Overriding Part of Another Makefile ::

example in GNUmakefile we have (demo) target but we dont have any other targets , in same directiry we have one makefile called Makefile, it   has one target called a.out but if we give the make in that directory it excutes only demo target , and if we give (make a.out) it shows no rule to make a.out so it is not reading Makefile.

the pattern rule has a pattern of just `%', so it matches any target whatever.
use this to go to Makefile file for any other targets except GNU targets.

%:
        @$(MAKE) -f Makefile $@

Wildcard Character(`*', `?' and `[...])::

Wildcard expansion happens automatically in targets, in prerequisites, and in commands
example:
clean:
        rm -f *.o
print: *.c
        lpr -p $?
        touch print

Wildcard expansion does not happen when you define a variable. Thus, if you write this:
objects = *.o
 then the value of the variable objects is the actual string `*.o'.


 However, if you use the value of objects in a target, prerequisite or command, wildcard expansion will take place at that time. To set objects to the expansion, instead use:

objects := $(wildcard *.o)
(cureent directory all .o)

 Wildcard expansion happens automatically in rules. But wildcard expansion does not normally take place when a variable is set, or inside the arguments of a function. If you want to do wildcard expansion in such places, you need to use the wildcard function, like this:

$(wildcard pattern...)


