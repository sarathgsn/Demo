When talking about toolchains, one must distinguish three different machines:

    The build machine, on which the toolchain is built
    The host machine, on which the toolchain is executed
    The target machine, for which the toolchain generates code

From these three different machines, we distinguish four different types of toolchain building processes:

    A native toolchain, as can be found in normal Linux distributions, has usually been compiled on x86, runs on x86 and generates code for x86.
    A cross-compilation toolchain, which is the most interesting toolchain type for embedded development, is typically compiled on x86, runs on x86 and generates code for the target architecture (be it ARM, MIPS, PowerPC or any other architecture supported by the different toolchain components)
    A cross-native toolchain, is a toolchain that has been built on x86, but runs on your target architecture and generates code for your target architecture. It's typically needed when you want a native GCC on your target platform, without building it on your target platform.
    A Canadian build is the process of building a toolchain on machine A, so that it runs on machine B and generates code for machine C. It's usually not really necessary.

Binutils::
Binutils
▶
Binutils
is a set of tools to generate and manipulate binaries
for a given CPU architecture
▶
as
, the assembler, that generates binary code from assembler
source code
▶
ld
, the linker
▶
ar
,
ranlib
, to generate
.a
archives, used for libraries
▶
objdump
,
readelf
,
size
,
nm
,
strings
, to inspect binaries.
Very useful analysis tools!
▶
strip
, to strip parts of binaries that are just needed for
debugging (reducing their size).


The GNU Binutils is the first component of a toolchain. The GNU Binutils contains two very important tools:

    as, the assembler, that turns assembly code (generated by GCC) to binary.
    ld, the linker, that links several object code into a library, or an executable.

Binutils also contains a couple of other binary file manipulation or analysis tools, such as objcopy, objdump, nm, readelf, strip, and so on. The Binutils website has some documentation on all these tools. 

COMPILER:;

The second major component of a toolchain is the compiler. In the embedded Linux,
 the only realistic solution today is GCC, the GNU Compiler Collection. Nowadays, as input, it not only supports C, but also C++, Java, Fortran, Objective-C and Ada. As output, it supports a very wide range of architectures. 

C library:

The C library implements the traditional POSIX API that can be used to develop userspace applications. It interfaces with the kernel through system calls and provides higher-level services.

Realistically, there are nowadays two options for the C Library:

    glibc is the C library from the GNU project. It's the C library used by virtually all desktop and server GNU/Linux systems. It's feature-full, portable, complies to standards, but a bit bloated.
    Embedded GLIBC (EGLIBC) is a variant of the GNU C Library (GLIBC) optimized for embedded systems. Its goals include reduced footprint, support for cross-compiling and cross-testing, while maintaining source and binary compatibility with GLIBC. The project is discontinued.
    uClibc is an alternate C library, which features a much smaller footprint. This library can be an interesting alternative if flash space and/or memory footprint is an issue. However, the space advantages gained using uClibc are becoming less important as the price of memory and flash continues to drop. It is still useful C library for embedded systems without an MMU.
    uClibc-ng is a spin-off of uClibc C library. The main goal of the spin-off is to do regular releases and do a lot of automatic runtime testing.
    musl New standard C library. musl is lightweight, fast, simple, free, and strives to be correct in the sense of standards-conformance and safety.

The C library has a special relation with the C compiler, so the choice of the C library must be done when the toolchain is generated. Once the toolchain has been built, it is no longer possible to switch to another library.

Debugger::

The debugger is also usually part of the toolchain, as a cross-debugger is needed to debug applications running on your target machine. In the embedded Linux world, the typical debugger is GDB.

Kernel_headers::




the C library and compiled rograms needs to interact with he kernel
▶
Available system calls and their umbers
▶
Constant definitions
▶
Data structures, etc.
▶
Therefore, compiling the C library equires kernel headers, and many applications also require them.
▶
Available in <linux/...> and <asm/...> and a few other directories corresponding to the ones visible in include/ in the kernel sources






The kernel to user space ABI is
backward compatible
▶
Binaries generated with a toolchain using kernel headers older
than the running kernel will work without problem, but won’t
be able to use the new system calls, data structures, etc.
▶
Binaries generated with a toolchain using kernel headers newer
than the running kernel might work on if they don’t use the
recent features, otherwise they will break
▶
Using the latest kernel headers is not necessary, unless access
to the new kernel features is needed
▶
The kernel headers are extracted from the kernel sources using
the
headers_install
kernel Makefile target.




When building a toolchain, the ABI used to generate binaries
needs to be defined
▶
ABI, for
Application Binary Interface
, defines the calling
conventions (how function arguments are passed, how the
return value is passed, how system calls are made) and the
organization of structures (alignment, etc.)
▶
All binaries in a system must be compiled with the same ABI,
and the kernel must understand this ABI.
▶
On ARM, two main ABIs:
OABI
and
EABI
▶
Nowadays everybody uses
EABI
▶
On MIPS, several ABIs:
o32, o64, n32, n64
▶
http://en.wikipedia.org/wiki/Application_Binary_Interface

Floating point support
▶
Some processors have a floating point unit, some others do
not.
▶
For example, many ARMv4 and ARMv5 CPUs do not have a
floating point unit. Since ARMv7, a VFP unit is mandatory.
▶
For processors having a floating point unit, the toolchain
should generate
hard float
code, in order to use the floating
point instructions directly
▶
For processors without a floating point unit, two solutions
▶
Generate
hard float code
and rely on the kernel to emulate the
floating point instructions. This is very slow.
▶
Generate
soft float code
, so that instead of generating floating
point instructions, calls to a user space library are generated
▶
Decision taken at toolchain configuration time
▶
Also possible to configure which floating point unit should be
use


Solution that many people choose
▶
Advantage: it is the simplest and most convenient solution
▶
Drawback: you can’t fine tune the toolchain to your needs
▶
Make sure the toolchain you find meets your requirements:
CPU, endianness, C library, component versions, ABI, soft
float or hard float, etc
	

Communication between components
Electronical components need to speak with each other, often they
exchange data with the CPU.
▶
Components are linked together with lines that ensure
electrical link
▶
Most of the time components are linked to the
CPU (SoC - System on Ship) or a microcontroller
▶
Many Components use buses to speak with each other or
GPIOs
▶
Soc usually implements many buses controllers


NOR is mandatory, because it allows random
access, which NAND doesn’t allow



